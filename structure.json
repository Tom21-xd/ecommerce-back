{
  "src": {
    "app.module.ts": "import { Module } from '@nestjs/common';\r\nimport { AppService } from './app.service';\r\nimport { AuthModule } from './auth/auth.module';\r\nimport { ProductsModule } from './products/products.module';\r\nimport { ProductContainerModule } from './product-container/product-container.module';\r\nimport { UsersModule } from './users/users.module';\r\n\r\n@Module({\r\n  imports: [AuthModule, ProductsModule, ProductContainerModule, UsersModule],\r\n  providers: [AppService],\r\n})\r\nexport class AppModule {}\r\n",
    "app.service.ts": "import { Injectable } from '@nestjs/common';\r\n\r\n@Injectable()\r\nexport class AppService {\r\n  getHello(): string {\r\n    return 'Hello World!';\r\n  }\r\n}\r\n",
    "auth": {
      "auth.controller.ts": "import {\r\n  Controller,\r\n  Post,\r\n  Body,\r\n  Req,\r\n  Res,\r\n  HttpStatus,\r\n  UsePipes,\r\n  ValidationPipe,\r\n  UseGuards,\r\n  Get,\r\n} from '@nestjs/common';\r\nimport { AuthService } from './auth.service';\r\nimport { RegisterUsersDto } from './dto/register-user.dto';\r\nimport { Request, Response } from 'express';\r\nimport { LoginDto } from './dto/login-user.dto';\r\nimport { JwtAuthGuard } from './jwt-auth.guard';\r\nimport { ApiBody, ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\r\n\r\n@Controller('auth')\r\n@ApiTags('Auth')\r\nexport class AuthController {\r\n  constructor(private authService: AuthService) {}\r\n\r\n  @Get('/validate')\r\n  @UseGuards(JwtAuthGuard)\r\n  @ApiOperation({ summary: 'Validate user token' })\r\n  @ApiResponse({\r\n    status: HttpStatus.OK,\r\n    description: 'Successfully validated the user token.',\r\n    schema: {\r\n      example: {\r\n        status: 'Ok!',\r\n        message: 'Success',\r\n        user: {\r\n          id: 'user-id',\r\n          name: 'John Doe',\r\n          email: 'johndoe@example.com',\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.UNAUTHORIZED,\r\n    description: 'User token is invalid or expired.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Unauthorized',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async validateSession(@Req() req: Request, @Res() response: Response) {\r\n    try {\r\n      const user = req.user as any;\r\n      const userId = user.id;\r\n\r\n      const userSession = await this.authService.validateSession(userId);\r\n      console.log('usersession executed', userSession);\r\n      return response.status(HttpStatus.OK).json({\r\n        status: 'Ok!',\r\n        message: 'Success',\r\n        user: userSession,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      response.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return response.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Post('/login')\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'login user' })\r\n  @ApiBody({\r\n    description: 'User login credentials',\r\n    type: LoginDto,\r\n    examples: {\r\n      example1: {\r\n        summary: 'Example of a login request',\r\n        value: {\r\n          email: 'user@example.com',\r\n          password: 'securepassword',\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.OK,\r\n    description: 'Successfully logged in the user.',\r\n    schema: {\r\n      example: {\r\n        status: 'Ok!',\r\n        message: 'Success',\r\n        result: {\r\n          token: 'jwt-token',\r\n          user: {\r\n            id: 'user-id',\r\n            name: 'John Doe',\r\n            email: 'johndoe@example.com',\r\n          },\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.UNAUTHORIZED,\r\n    description: 'Invalid credentials provided.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Unauthorized',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.BAD_REQUEST,\r\n    description: 'Validation failed for the provided input.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Validation failed',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async login(\r\n    @Req() req: Request,\r\n    @Res() response: Response,\r\n    @Body() userData: LoginDto,\r\n  ) {\r\n    try {\r\n      const data = await this.authService.login(userData);\r\n      console.log(data);\r\n      return response.status(HttpStatus.OK).json({\r\n        status: 'Ok!',\r\n        message: 'Success',\r\n        result: {\r\n          token: data.token,\r\n          user: data.user,\r\n        },\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      response.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return response.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Post('/register')\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'Register user' })\r\n  @ApiBody({\r\n    description: 'User registration credentials',\r\n    type: RegisterUsersDto,\r\n    examples: {\r\n      example1: {\r\n        summary: 'Example of a registration request',\r\n        value: {\r\n          username: 'newuser',\r\n          password: 'securepassword',\r\n          email: 'user@example.com',\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.CREATED,\r\n    description: 'Successfully registered the user.',\r\n    schema: {\r\n      example: {\r\n        status: 'Ok!',\r\n        message: 'Successfully registered user!',\r\n        result: {\r\n          token: 'jwt-token',\r\n          user: {\r\n            id: 'user-id',\r\n            name: 'John Doe',\r\n            email: 'johndoe@example.com',\r\n          },\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.BAD_REQUEST,\r\n    description: 'Validation failed for the provided input.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Validation failed',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.CONFLICT,\r\n    description: 'User already exists.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'User already exists',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async register(\r\n    @Req() request: Request,\r\n    @Res() response: Response,\r\n    @Body() registerDto: RegisterUsersDto,\r\n  ): Promise<any> {\r\n    try {\r\n      const data = await this.authService.register(registerDto);\r\n      return response.status(HttpStatus.CREATED).json({\r\n        status: 'Ok!',\r\n        message: 'Successfully register user!',\r\n        result: {\r\n          token: data.token,\r\n          user: data.user,\r\n        },\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      response.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return response.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n}\r\n",
      "auth.module.ts": "import { Module } from '@nestjs/common';\r\nimport { AuthService } from './auth.service';\r\nimport { AuthController } from './auth.controller';\r\nimport { PassportModule } from '@nestjs/passport';\r\nimport { JwtModule } from '@nestjs/jwt';\r\nimport { jwtConstants } from './constants';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\nimport { JwtStrategy } from './strategies/jwt.strategy';\r\n\r\n@Module({\r\n  imports: [\r\n    PassportModule,\r\n    JwtModule.register({\r\n      secret: jwtConstants.secret,\r\n      signOptions: { expiresIn: jwtConstants.expiresIn },\r\n    }),\r\n  ],\r\n  providers: [AuthService, PrismaService, JwtStrategy],\r\n  controllers: [AuthController],\r\n})\r\nexport class AuthModule {}\r\n",
      "auth.service.ts": "import {\r\n  ConflictException,\r\n  Injectable,\r\n  NotFoundException,\r\n} from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { LoginDto } from './dto/login-user.dto';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\nimport * as bcrypt from 'bcrypt';\r\nimport { RegisterUsersDto } from './dto/register-user.dto';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n  constructor(\r\n    private JwtService: JwtService,\r\n    private prismaService: PrismaService,\r\n  ) {}\r\n\r\n  async validateSession(userId: number) {\r\n    const user = await this.prismaService.user.findUnique({\r\n      where: { id: userId },\r\n    });\r\n\r\n    if (!user) throw new NotFoundException('User does not exists');\r\n\r\n    return {\r\n      id: user.id,\r\n      email: user.email,\r\n      username: user.username,\r\n      role: user.role,\r\n    };\r\n  }\r\n\r\n  async login(user: LoginDto): Promise<any> {\r\n    const { email, password } = user;\r\n    const searchUser = await this.prismaService.user.findUnique({\r\n      where: { email },\r\n    });\r\n    console.log('search usa', searchUser);\r\n    if (!searchUser) {\r\n      throw new NotFoundException('user not found');\r\n    }\r\n\r\n    const validatePassword = await bcrypt.compare(\r\n      password,\r\n      searchUser.password,\r\n    );\r\n\r\n    if (!validatePassword) throw new NotFoundException('Invalid password');\r\n\r\n    const returnUser = {\r\n      id: searchUser.id,\r\n      username: searchUser.username,\r\n      email: searchUser.email,\r\n      role: searchUser.role,\r\n    };\r\n\r\n    return {\r\n      token: this.JwtService.sign({\r\n        user: {\r\n          id: searchUser.id,\r\n          role: searchUser.role,\r\n          email: searchUser.email,\r\n        },\r\n      }),\r\n      user: returnUser,\r\n    };\r\n  }\r\n\r\n  async register(userData: RegisterUsersDto): Promise<any> {\r\n    const exists = await this.prismaService.user.findUnique({\r\n      where: {\r\n        email: userData.email,\r\n      },\r\n    });\r\n\r\n    if (exists) throw new ConflictException('email already exists');\r\n\r\n    const user = await this.prismaService.user.create({\r\n      data: {\r\n        ...userData,\r\n        password: (userData.password = await bcrypt.hash(\r\n          userData.password,\r\n          10,\r\n        )),\r\n        role: 'SELLER',\r\n      },\r\n    });\r\n\r\n    console.log('usa', user);\r\n    const returnUser = {\r\n      id: user.id,\r\n      username: user.username,\r\n      email: user.email,\r\n      role: user.role,\r\n    };\r\n\r\n    return {\r\n      token: this.JwtService.sign({\r\n        user: {\r\n          id: user.id,\r\n          role: user.role,\r\n          email: user.email,\r\n        },\r\n      }),\r\n      user: returnUser,\r\n    };\r\n  }\r\n}\r\n",
      "constants.ts": "export const jwtConstants = {\r\n  secret: process.env.JWT_SECRET,\r\n  expiresIn: process.env.EXPIRES_IN,\r\n};\r\n",
      "decorators": {
        "public.decorator.ts": "import { SetMetadata } from '@nestjs/common';\r\n\r\nexport const IS_PUBLIC_KEY = 'isPublic';\r\n\r\nexport const Public = () => SetMetadata(IS_PUBLIC_KEY, true);\r\n"
      },
      "dto": {
        "login-user.dto.ts": "import { IsEmail, IsString, Length } from 'class-validator';\r\n\r\nexport class LoginDto {\r\n  @IsString()\r\n  @Length(5)\r\n  @IsEmail()\r\n  email: string;\r\n\r\n  @IsString()\r\n  @Length(6, 32)\r\n  password: string;\r\n}\r\n",
        "register-user.dto.ts": "import { IsEmail, IsString, Length } from 'class-validator';\r\n\r\nexport class RegisterUsersDto {\r\n  @IsString()\r\n  @Length(5, 20)\r\n  username: string;\r\n\r\n  @IsString()\r\n  @Length(6, 12)\r\n  password: string;\r\n\r\n  @IsString()\r\n  @Length(5, 30)\r\n  @IsEmail()\r\n  email: string;\r\n}\r\n",
        "token.dto.ts": "export class PayloadToken {\r\n  user: {\r\n    email: string;\r\n  };\r\n}\r\n"
      },
      "jwt-auth.guard.ts": "import { ExecutionContext, Injectable } from '@nestjs/common';\r\nimport { Reflector } from '@nestjs/core';\r\nimport { AuthGuard } from '@nestjs/passport';\r\nimport { IS_PUBLIC_KEY } from './decorators/public.decorator';\r\n\r\n@Injectable()\r\nexport class JwtAuthGuard extends AuthGuard('jwt') {\r\n  constructor(private reflector: Reflector) {\r\n    super();\r\n  }\r\n\r\n  canActivate(context: ExecutionContext) {\r\n    const isPublic = this.reflector.get(IS_PUBLIC_KEY, context.getHandler());\r\n    if (isPublic) return true;\r\n    return super.canActivate(context);\r\n  }\r\n}\r\n",
      "strategies": {
        "jwt.strategy.ts": "import { Injectable } from '@nestjs/common';\r\nimport { PassportStrategy } from '@nestjs/passport';\r\nimport { ExtractJwt, Strategy } from 'passport-jwt';\r\nimport { PayloadToken } from '../dto/token.dto';\r\nimport { jwtConstants } from '../constants';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\n\r\n@Injectable()\r\nexport class JwtStrategy extends PassportStrategy(Strategy) {\r\n  constructor(private prismaService: PrismaService) {\r\n    super({\r\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\r\n      ignoreExpiration: false,\r\n      secretOrKey: jwtConstants.secret,\r\n    });\r\n  }\r\n\r\n  async validate(payload: PayloadToken) {\r\n    console.log('strategy', payload);\r\n    const users = await this.prismaService.user.findUnique({\r\n      where: {\r\n        email: payload?.user.email,\r\n      },\r\n    });\r\n\r\n    return users;\r\n  }\r\n}\r\n"
      }
    },
    "cart": {
      "cart.controller.ts": "import {\r\n  Controller,\r\n  Post,\r\n  Body,\r\n  Req,\r\n  UseGuards,\r\n  UsePipes,\r\n  ValidationPipe,\r\n  Res,\r\n  HttpStatus,\r\n  Get,\r\n  Query,\r\n} from '@nestjs/common';\r\nimport { JwtAuthGuard } from 'src/auth/jwt-auth.guard';\r\nimport { Request, Response } from 'express';\r\nimport { PaginationDto } from 'src/common/dto/pagination.dto';\r\nimport { RolesGuard } from 'src/common/guards/roles.guard';\r\nimport { Roles } from 'src/common/decorators/roles.decorator';\r\nimport { ApiBody, ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\r\nimport { cartsService } from './cart.service';\r\n\r\n@Controller('cart')\r\n@ApiTags('cart')\r\n@UseGuards(JwtAuthGuard)\r\nexport class cartController {\r\n  constructor(private readonly cartService: cartsService) {}\r\n\r\n}\r\n",
      "cart.module.ts": "import { Module } from '@nestjs/common';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\nimport { ProductContainerService } from 'src/product-container/product-container.service';\r\nimport { cartController } from './cart.controller';\r\nimport { cartsService } from './cart.service';\r\n\r\n@Module({\r\n  controllers: [cartController],\r\n  providers: [cartsService, PrismaService, ProductContainerService],\r\n})\r\nexport class ProductsModule {}\r\n",
      "cart.service.ts": "import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\nimport { PaginationDto } from 'src/common/dto/pagination.dto';\r\n\r\n@Injectable()\r\nexport class cartsService {\r\n  constructor(\r\n    private JwtService: JwtService,\r\n    private prismaService: PrismaService,\r\n  ) {}\r\n\r\n\r\n}\r\n",
      "dto": {
        "add-item.dto.ts": "import { IsInt, Min } from 'class-validator';\r\n\r\nexport class AddItemDto {\r\n  @IsInt()\r\n  @Min(1)\r\n  productId: number;\r\n\r\n  @IsInt()\r\n  @Min(1)\r\n  qty: number;\r\n}\r\n",
        "checkout.dto.ts": "import { IsInt, IsOptional, Min } from 'class-validator';\r\n\r\nexport class CheckoutDto {\r\n  @IsOptional()\r\n  @IsInt()\r\n  @Min(1)\r\n  addressId?: number; \r\n}\r\n",
        "update-item.dto.ts": "import { IsInt, Min } from 'class-validator';\r\n\r\nexport class UpdateItemDto {\r\n  @IsInt()\r\n  @Min(0)\r\n  qty: number; \r\n}\r\n"
      }
    },
    "common": {
      "decorators": {
        "roles.decorator.ts": "import { SetMetadata } from '@nestjs/common';\r\n\r\nexport const Roles = (...roles: string[]) => SetMetadata('roles', roles);\r\n"
      },
      "dto": {
        "pagination.dto.ts": "import { IsOptional, IsInt, Min } from 'class-validator';\r\nimport { Type } from 'class-transformer';\r\n\r\nexport class PaginationDto {\r\n  @IsOptional()\r\n  @Type(() => Number)\r\n  @IsInt()\r\n  @Min(1)\r\n  limit?: number;\r\n\r\n  @IsOptional()\r\n  @Type(() => Number)\r\n  @IsInt()\r\n  @Min(0)\r\n  offset?: number;\r\n}\r\n"
      },
      "guards": {
        "roles.guard.ts": "import {\r\n  Injectable,\r\n  CanActivate,\r\n  ExecutionContext,\r\n  ForbiddenException,\r\n} from '@nestjs/common';\r\nimport { Reflector } from '@nestjs/core';\r\nimport { User } from 'src/auth/entities/user.entity';\r\n\r\n@Injectable()\r\nexport class RolesGuard implements CanActivate {\r\n  constructor(private reflector: Reflector) {}\r\n\r\n  canActivate(context: ExecutionContext): boolean {\r\n    const requiredRoles = this.reflector.get<string[]>(\r\n      'roles',\r\n      context.getHandler(),\r\n    );\r\n    if (!requiredRoles) {\r\n      return true; // Si no hay roles requeridos, permite el acceso\r\n    }\r\n\r\n    const request = context.switchToHttp().getRequest();\r\n    const user: User = request.user; // Suponiendo que el usuario se establece en la solicitud por el guardia JWT\r\n\r\n    if (!user || !requiredRoles.includes(user.role)) {\r\n      throw new ForbiddenException(\r\n        'You do not have the necessary permissions to access this resource.',\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n}\r\n"
      }
    },
    "main.ts": "import { NestFactory } from '@nestjs/core';\r\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\r\nimport { AppModule } from './app.module';\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n\r\n  const config = new DocumentBuilder()\r\n    .setTitle('Marketplace')\r\n    .setDescription('Marketplace prueba tecnica')\r\n    .setVersion('1.0')\r\n    .build();\r\n\r\n  const document = SwaggerModule.createDocument(app, config);\r\n  SwaggerModule.setup('api', app, document);\r\n\r\n  app.enableCors();\r\n  await app.listen(process.env.PORT || 4000);\r\n}\r\nbootstrap();\r\n",
    "prisma": {
      "prisma.service.ts": "import { Injectable, OnModuleInit } from '@nestjs/common';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\n@Injectable()\r\nexport class PrismaService extends PrismaClient implements OnModuleInit {\r\n  async onModuleInit() {\r\n    await this.$connect();\r\n  }\r\n}\r\n"
    },
    "product-container": {
      "dto": {
        "create-product-container.dto.ts": "export class CreateProductContainerDto {\r\n  name: string;\r\n\r\n  userId: number;\r\n}\r\n",
        "update-product-container.dto.ts": "import { PartialType } from '@nestjs/mapped-types';\r\nimport { CreateProductContainerDto } from './create-product-container.dto';\r\n\r\nexport class UpdateProductContainerDto extends PartialType(CreateProductContainerDto) {}\r\n"
      },
      "entities": {
        "product-container.entity.ts": "export class ProductContainer {}\r\n"
      },
      "product-container.controller.ts": "import { Controller, Post, Body, Get, Req, UseGuards } from '@nestjs/common';\r\nimport { ProductContainerService } from './product-container.service';\r\nimport { CreateProductContainerDto } from './dto/create-product-container.dto';\r\nimport { Request } from 'express';\r\nimport { JwtAuthGuard } from 'src/auth/jwt-auth.guard';\r\nimport { ApiTags } from '@nestjs/swagger';\r\n\r\n@Controller('product-container')\r\n@ApiTags('Product Container')\r\nexport class ProductContainerController {\r\n  constructor(\r\n    private readonly productContainerService: ProductContainerService,\r\n  ) {}\r\n\r\n  @Post()\r\n  async create(@Body() createProductContainerDto: CreateProductContainerDto) {\r\n    return this.productContainerService.create(createProductContainerDto);\r\n  }\r\n\r\n  @Get()\r\n  @UseGuards(JwtAuthGuard)\r\n  async getContainer(@Req() req: Request) {\r\n    const user = req.user as any;\r\n    const userId = user.id;\r\n    return this.productContainerService.getProductContainer(userId);\r\n  }\r\n}\r\n",
      "product-container.module.ts": "import { Module } from '@nestjs/common';\r\nimport { ProductContainerService } from './product-container.service';\r\nimport { ProductContainerController } from './product-container.controller';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\n\r\n@Module({\r\n  controllers: [ProductContainerController],\r\n  providers: [ProductContainerService, PrismaService],\r\n})\r\nexport class ProductContainerModule {}\r\n",
      "product-container.service.ts": "import { Injectable } from '@nestjs/common';\r\nimport { CreateProductContainerDto } from './dto/create-product-container.dto';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\n\r\n@Injectable()\r\nexport class ProductContainerService {\r\n  constructor(\r\n    // private JwtService: JwtService,\r\n    private prismaService: PrismaService,\r\n  ) {}\r\n\r\n  async create(createProductContainerDto: CreateProductContainerDto) {\r\n    const { name, userId } = createProductContainerDto;\r\n\r\n    const productContainer = await this.prismaService.productContainer.create({\r\n      data: {\r\n        name,\r\n        userId,\r\n      },\r\n    });\r\n\r\n    return productContainer;\r\n  }\r\n\r\n  async getProductContainer(id: number) {\r\n    const containers = await this.prismaService.productContainer.findMany({\r\n      where: { user: { id } },\r\n    });\r\n\r\n    return containers;\r\n  }\r\n}\r\n"
    },
    "products": {
      "dto": {
        "create-product.dto.ts": "import {\r\n  IsInt,\r\n  IsNotEmpty,\r\n  IsNumber,\r\n  IsPositive,\r\n  IsString,\r\n} from 'class-validator';\r\n\r\nexport class CreateProductDto {\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  name: string;\r\n\r\n  @IsString()\r\n  sku: string;\r\n\r\n  @IsInt()\r\n  @IsNotEmpty()\r\n  quantity: number;\r\n\r\n  @IsNumber()\r\n  @IsPositive()\r\n  price: number;\r\n\r\n  containerId: number;\r\n}\r\n",
        "update-product.dto.ts": "import { PartialType } from '@nestjs/mapped-types';\r\nimport { CreateProductDto } from './create-product.dto';\r\n\r\nexport class UpdateProductDto extends PartialType(CreateProductDto) {}\r\n"
      },
      "entities": {
        "product.entity.ts": "export class Product {}\r\n"
      },
      "products.controller.ts": "import {\r\n  Controller,\r\n  Post,\r\n  Body,\r\n  Req,\r\n  UseGuards,\r\n  UsePipes,\r\n  ValidationPipe,\r\n  Res,\r\n  HttpStatus,\r\n  Get,\r\n  Query,\r\n} from '@nestjs/common';\r\nimport { ProductsService } from './products.service';\r\nimport { CreateProductDto } from './dto/create-product.dto';\r\nimport { JwtAuthGuard } from 'src/auth/jwt-auth.guard';\r\nimport { Request, Response } from 'express';\r\nimport { PaginationDto } from 'src/common/dto/pagination.dto';\r\nimport { RolesGuard } from 'src/common/guards/roles.guard';\r\nimport { Roles } from 'src/common/decorators/roles.decorator';\r\nimport { Role } from 'src/auth/entities/role.enum';\r\nimport { ApiBody, ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\r\n\r\n@Controller('products')\r\n@ApiTags('Products')\r\nexport class ProductsController {\r\n  constructor(private readonly productsService: ProductsService) {}\r\n\r\n  @Post()\r\n  @UseGuards(JwtAuthGuard)\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'Create product' })\r\n  @ApiBody({\r\n    description: 'Data required to create a product',\r\n    type: CreateProductDto,\r\n    examples: {\r\n      example1: {\r\n        summary: 'Example of a product creation request',\r\n        value: {\r\n          name: 'Sample Product',\r\n          sku: 'SP-001',\r\n          quantity: 10,\r\n          price: 99.99,\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.CREATED,\r\n    description: 'Product has been created successfully.',\r\n    schema: {\r\n      example: {\r\n        status: 201,\r\n        message: 'Product has been created successfully',\r\n        result: {\r\n          id: 'product-id',\r\n          name: 'Sample Product',\r\n          price: 100,\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.BAD_REQUEST,\r\n    description: 'Validation failed for the provided input.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Validation failed',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.UNAUTHORIZED,\r\n    description: 'User is not authorized to create a product.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Unauthorized',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async create(\r\n    @Req() req: Request,\r\n    @Res() res: Response,\r\n    @Body() createProductDto: CreateProductDto,\r\n  ) {\r\n    const user = req.user as any;\r\n    const userId = user.id;\r\n    try {\r\n      const result = await this.productsService.create(\r\n        createProductDto,\r\n        userId,\r\n      );\r\n      return res.status(HttpStatus.CREATED).json({\r\n        status: 201,\r\n        message: 'Product has been created successfully',\r\n        result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n\r\n      res.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return res.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Get()\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'Get all products' })\r\n  @ApiResponse({\r\n    status: HttpStatus.OK,\r\n    description: 'Successfully retrieved products.',\r\n    schema: {\r\n      example: {\r\n        status: 200,\r\n        message: 'ok',\r\n        result: {\r\n          products: [\r\n            {\r\n              id: 'product-id-1',\r\n              name: 'Sample Product 1',\r\n              price: 100,\r\n            },\r\n            {\r\n              id: 'product-id-2',\r\n              name: 'Sample Product 2',\r\n              price: 200,\r\n            },\r\n          ],\r\n          totalPages: 1,\r\n          totaProduct: 1000,\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.BAD_REQUEST,\r\n    description: 'Validation failed for the provided input.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Validation failed',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async getAllUserProducts(\r\n    @Req() req: Request,\r\n    @Res() res: Response,\r\n    @Query() pagination: PaginationDto,\r\n  ) {\r\n    try {\r\n      const result = await this.productsService.getAllProducts(pagination);\r\n\r\n      return res.status(HttpStatus.OK).json({\r\n        staus: 200,\r\n        message: 'ok',\r\n        result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      res.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return res.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Get('/admin')\r\n  @UseGuards(JwtAuthGuard, RolesGuard)\r\n  @Roles(Role.ADMIN)\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'Get all products with user role equal to SELLER' })\r\n  @ApiResponse({\r\n    status: HttpStatus.OK,\r\n    description: 'Successfully retrieved products with user information.',\r\n    schema: {\r\n      example: {\r\n        status: 200,\r\n        message: 'ok',\r\n        result: {\r\n          products: [\r\n            {\r\n              productId: 'product-id-1',\r\n              name: 'Sample Product 1',\r\n              price: 100,\r\n              user: {\r\n                id: 'seller-id-1',\r\n                username: 'Seller1',\r\n              },\r\n            },\r\n            {\r\n              productId: 'product-id-2',\r\n              name: 'Sample Product 2',\r\n              price: 200,\r\n              user: {\r\n                id: 'seller-id-2',\r\n                username: 'Seller2',\r\n              },\r\n            },\r\n          ],\r\n          totalPages: 1,\r\n          totaProduct: 1000,\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.UNAUTHORIZED,\r\n    description: 'User is not authorized.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Unauthorized',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.FORBIDDEN,\r\n    description: 'User does not have the required role.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Forbidden',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async getAllUserProductsWithUserInfo(\r\n    @Req() req: Request,\r\n    @Res() res: Response,\r\n    @Query() pagination: PaginationDto,\r\n  ) {\r\n    try {\r\n      const result =\r\n        await this.productsService.getAllProductsWithUserData(pagination);\r\n\r\n      return res.status(HttpStatus.OK).json({\r\n        staus: 200,\r\n        message: 'ok',\r\n        result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      res.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return res.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Get('/user')\r\n  @UseGuards(JwtAuthGuard)\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'Get all products related to an userId' })\r\n  @ApiResponse({\r\n    status: HttpStatus.OK,\r\n    description: 'Successfully retrieved products related to the user.',\r\n    schema: {\r\n      example: {\r\n        status: 200,\r\n        message: 'ok',\r\n        result: {\r\n          products: [\r\n            {\r\n              id: 'product-id-1',\r\n              name: 'Sample Product 1',\r\n              price: 100,\r\n            },\r\n            {\r\n              id: 'product-id-2',\r\n              name: 'Sample Product 2',\r\n              price: 200,\r\n            },\r\n          ],\r\n          totalPages: 1,\r\n          totaProduct: 1000,\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.UNAUTHORIZED,\r\n    description: 'Unauthorized access. User is not authenticated.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Unauthorized access.',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async getAllProductsByUser(\r\n    @Req() req: Request,\r\n    @Res() res: Response,\r\n    @Query() pagination: PaginationDto,\r\n  ) {\r\n    const user = req.user as any;\r\n    const userId = user.id;\r\n\r\n    try {\r\n      const result = await this.productsService.getAllProductsByUser(\r\n        userId,\r\n        pagination,\r\n      );\r\n\r\n      return res.status(HttpStatus.OK).json({\r\n        staus: 200,\r\n        message: 'ok',\r\n        result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n\r\n      res.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return res.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Get('/match')\r\n  @UsePipes(new ValidationPipe())\r\n  @ApiOperation({ summary: 'Get products that match with query' })\r\n  @ApiResponse({\r\n    status: HttpStatus.OK,\r\n    description: 'Successfully retrieved matching products.',\r\n    schema: {\r\n      example: {\r\n        status: 200,\r\n        message: 'ok',\r\n        result: {\r\n          products: [\r\n            {\r\n              id: 'product-id-1',\r\n              name: 'Sample Product 1',\r\n              price: 100,\r\n            },\r\n            {\r\n              id: 'product-id-2',\r\n              name: 'Sample Product 2',\r\n              price: 200,\r\n            },\r\n          ],\r\n          totalPages: 1,\r\n          totaProduct: 1000,\r\n        },\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.BAD_REQUEST,\r\n    description: 'Invalid query parameters.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'Invalid query parameters.',\r\n      },\r\n    },\r\n  })\r\n  @ApiResponse({\r\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n    description: 'An unexpected error occurred.',\r\n    schema: {\r\n      example: {\r\n        status: 'Error',\r\n        message: 'An unexpected error occurred.',\r\n      },\r\n    },\r\n  })\r\n  async getMatchProduct(\r\n    @Req() req: Request,\r\n    @Res() res: Response,\r\n    @Query() query: { name: string },\r\n  ) {\r\n    try {\r\n      const result = await this.productsService.getMatchProducts(query);\r\n\r\n      return res.status(HttpStatus.OK).json({\r\n        staus: 200,\r\n        message: 'ok',\r\n        result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n\r\n      res.statusMessage = err.response?.message || 'Internal Server Error';\r\n      return res.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n}\r\n",
      "products.module.ts": "import { Module } from '@nestjs/common';\r\nimport { ProductsService } from './products.service';\r\nimport { ProductsController } from './products.controller';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\nimport { ProductContainerService } from 'src/product-container/product-container.service';\r\n\r\n@Module({\r\n  controllers: [ProductsController],\r\n  providers: [ProductsService, PrismaService, ProductContainerService],\r\n})\r\nexport class ProductsModule {}\r\n",
      "products.service.ts": "import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { CreateProductDto } from './dto/create-product.dto';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\nimport { ProductContainerService } from 'src/product-container/product-container.service';\r\nimport { PaginationDto } from 'src/common/dto/pagination.dto';\r\n\r\n@Injectable()\r\nexport class ProductsService {\r\n  constructor(\r\n    // private JwtService: JwtService,\r\n    private prismaService: PrismaService,\r\n    private productContainerService: ProductContainerService,\r\n  ) {}\r\n\r\n  async create(createProductDto: CreateProductDto, id: number | null) {\r\n    const { name, sku, quantity, price, containerId } = createProductDto;\r\n\r\n    console.log('user', id);\r\n\r\n    const existingProduct = await this.prismaService.product.findUnique({\r\n      where: { sku },\r\n    });\r\n\r\n    if (existingProduct) {\r\n      throw new NotFoundException('Product with this SKU already exists.');\r\n    }\r\n\r\n    let productContainerId;\r\n\r\n    if (!containerId) {\r\n      console.log('creating product container');\r\n\r\n      const productContainer = await this.productContainerService.create({\r\n        name: '',\r\n        userId: id,\r\n      });\r\n\r\n      productContainerId = productContainer.id;\r\n      console.log('productContainerId', productContainerId);\r\n    }\r\n\r\n    const product = await this.prismaService.product.create({\r\n      data: {\r\n        name,\r\n        sku,\r\n        quantity,\r\n        price,\r\n        containerId: containerId || productContainerId,\r\n      },\r\n    });\r\n\r\n    return product;\r\n  }\r\n\r\n  async getAllProducts(paginationDTO: PaginationDto) {\r\n    const { limit = 10, offset = 0 } = paginationDTO;\r\n\r\n    const totalProducts = await this.prismaService.product.count();\r\n\r\n    const products = await this.prismaService.product.findMany({\r\n      skip: Number(offset),\r\n      take: Number(limit),\r\n    });\r\n\r\n    const totalPages = Math.ceil(totalProducts / limit);\r\n\r\n    return {\r\n      products,\r\n      totalPages,\r\n      totalProducts,\r\n    };\r\n  }\r\n\r\n  async getAllProductsWithUserData(paginationDTO: PaginationDto) {\r\n    const { limit = 10, offset = 0 } = paginationDTO;\r\n\r\n    const totalProducts = await this.prismaService.product.count({\r\n      where: {\r\n        container: {\r\n          user: {\r\n            role: 'SELLER',\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const products = await this.prismaService.product.findMany({\r\n      where: {\r\n        container: {\r\n          user: {\r\n            role: 'SELLER',\r\n          },\r\n        },\r\n      },\r\n      skip: Number(offset),\r\n      take: Number(limit),\r\n      include: {\r\n        container: {\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                email: true,\r\n                username: true,\r\n                role: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const totalPages = Math.ceil(totalProducts / limit);\r\n\r\n    return {\r\n      products,\r\n      totalPages,\r\n      totalProducts,\r\n    };\r\n  }\r\n\r\n  async getAllProductsByUser(userId: number, paginationDTO: PaginationDto) {\r\n    const { limit = 10, offset = 0 } = paginationDTO;\r\n\r\n    const totalProducts = await this.prismaService.product.count({\r\n      where: {\r\n        container: {\r\n          userId,\r\n        },\r\n      },\r\n    });\r\n\r\n    const products = await this.prismaService.product.findMany({\r\n      where: {\r\n        container: {\r\n          userId,\r\n        },\r\n      },\r\n      skip: Number(offset),\r\n      take: Number(limit),\r\n    });\r\n\r\n    const totalPages = Math.ceil(totalProducts / limit);\r\n\r\n    return {\r\n      products,\r\n      totalPages,\r\n      totalProducts,\r\n    };\r\n  }\r\n\r\n  async getMatchProducts(query: { name: string }) {\r\n    const { name } = query;\r\n\r\n    const products = await this.prismaService.product.findMany({\r\n      where: {\r\n        OR: [\r\n          {\r\n            name: {\r\n              contains: name,\r\n              mode: 'insensitive',\r\n            },\r\n          },\r\n          {\r\n            sku: {\r\n              contains: name,\r\n              mode: 'insensitive',\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    });\r\n\r\n    const totalProducts = products.length;\r\n    const totalPages = Math.ceil(totalProducts / 10);\r\n\r\n    return {\r\n      products,\r\n      totalPages,\r\n      totalProducts,\r\n    };\r\n  }\r\n}\r\n"
    },
    "users": {
      "users.controller.ts": "import {\r\n  Controller,\r\n  Param,\r\n  Delete,\r\n  Req,\r\n  Res,\r\n  Get,\r\n  Query,\r\n  UseGuards,\r\n} from '@nestjs/common';\r\nimport { UsersService } from './users.service';\r\nimport { Request, Response } from 'express';\r\nimport { Role } from '@prisma/client';\r\nimport { JwtAuthGuard } from 'src/auth/jwt-auth.guard';\r\nimport { ApiOperation, ApiTags } from '@nestjs/swagger';\r\nimport { Roles } from 'src/common/decorators/roles.decorator';\r\n\r\n@Controller('users')\r\n@ApiTags('Users')\r\nexport class UsersController {\r\n  constructor(private readonly usersService: UsersService) {}\r\n\r\n  @Get('/all')\r\n  @UseGuards(JwtAuthGuard)\r\n  @ApiOperation({ summary: 'Get all users' })\r\n  async getAllUsers(@Req() req: Request, @Res() response: Response) {\r\n    try {\r\n      const result = await this.usersService.getAllusers();\r\n      return response.status(200).json({\r\n        status: 'Ok!',\r\n        message: 'Successfully fetch data!',\r\n        result: result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      response.statusMessage = err.response.message;\r\n      return response.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Get('/by-role')\r\n  @UseGuards(JwtAuthGuard)\r\n  @ApiOperation({ summary: 'Get all users by role' })\r\n  async getUsersByRole(\r\n    @Req() req: Request,\r\n    @Res() response: Response,\r\n    @Query('role') role: string,\r\n  ) {\r\n    try {\r\n      const result = await this.usersService.getAllUsersByRole(\r\n        role.toUpperCase() as Role,\r\n      );\r\n      return response.status(200).json({\r\n        status: 'Ok!',\r\n        message: 'Successfully fetch data!',\r\n        result: result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      response.statusMessage = err.response.message;\r\n      return response.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n\r\n  @Delete(':id')\r\n  @UseGuards(JwtAuthGuard)\r\n  @Roles(Role.ADMIN)\r\n  @ApiOperation({ summary: 'Delete user by id' })\r\n  async remove(\r\n    @Req() req: Request,\r\n    @Res() response: Response,\r\n    @Param('id') id: string,\r\n  ) {\r\n    try {\r\n      const result = await this.usersService.remove(+id);\r\n      return response.status(200).json({\r\n        status: 'Ok!',\r\n        message: 'User deleted',\r\n        result: result,\r\n      });\r\n    } catch (err) {\r\n      console.log(err);\r\n      response.statusMessage = err.response.message;\r\n      return response.status(err.status).json({\r\n        status: err.response.statusCode,\r\n        message: err.response.message,\r\n      });\r\n    }\r\n  }\r\n}\r\n",
      "users.module.ts": "import { Module } from '@nestjs/common';\r\nimport { UsersService } from './users.service';\r\nimport { UsersController } from './users.controller';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\n\r\n@Module({\r\n  controllers: [UsersController],\r\n  providers: [UsersService, PrismaService],\r\n})\r\nexport class UsersModule {}\r\n",
      "users.service.ts": "import { Injectable, NotFoundException } from '@nestjs/common';\r\nimport { Role } from '@prisma/client';\r\nimport { PrismaService } from 'src/prisma/prisma.service';\r\n\r\n@Injectable()\r\nexport class UsersService {\r\n  constructor(private prisma: PrismaService) {}\r\n\r\n  async getAllusers() {\r\n    console.log('entro aca');\r\n    return await this.prisma.user.findMany();\r\n  }\r\n\r\n  async getAllUsersByRole(role: Role) {\r\n    const users = await this.prisma.user.findMany({\r\n      where: {\r\n        role: role,\r\n      },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        username: true,\r\n        role: true,\r\n        createdAt: true,\r\n      },\r\n    });\r\n\r\n    if (!users)\r\n      throw new NotFoundException('Users with this role do not exists');\r\n\r\n    return users;\r\n  }\r\n\r\n  async remove(id: number) {\r\n    const user = await this.prisma.user.findUnique({\r\n      where: {\r\n        id,\r\n      },\r\n    });\r\n\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    return this.prisma.user.delete({\r\n      where: { id },\r\n    });\r\n  }\r\n}\r\n"
    }
  }
}